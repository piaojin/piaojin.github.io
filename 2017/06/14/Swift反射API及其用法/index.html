<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
   
    <meta name="keywords" content="iOS,Swift" />
  
  
  
  
  <title>Swift反射API及其用法 | 飘金的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Swift反射API及其用法">
<meta name="keywords" content="iOS,Swift">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift反射API及其用法">
<meta property="og:url" content="http://yoursite.com/2017/06/14/Swift反射API及其用法/index.html">
<meta property="og:site_name" content="飘金的博客">
<meta property="og:description" content="Swift反射API及其用法">
<meta property="og:updated_time" content="2017-06-14T14:13:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift反射API及其用法">
<meta name="twitter:description" content="Swift反射API及其用法">
  
    <link rel="alternative" href="/atom.xml" title="飘金的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">飘金</a></h1>
        </hgroup>
        
        <p class="header-subtitle">会炒菜的猿</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder=" Search...">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/开发工具/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/cognition">认知提升</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">飘金</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">飘金</a></h1>
            </hgroup>
            
            <p class="header-subtitle">会炒菜的猿</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/开发工具/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/cognition">认知提升</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Swift反射API及其用法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/06/14/Swift反射API及其用法/" class="article-date">
      <time datetime="2017-06-14T06:23:47.000Z" itemprop="datePublished">2017-06-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Swift反射API及其用法
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Swift反射API及其用法<br><a id="more"></a></p>
<h2 id="尽管-Swift-一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi-Packets和Core-Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福-Macoun会议上的一次演讲，它对-Swift-的反射-API-做了一个概述。"><a href="#尽管-Swift-一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi-Packets和Core-Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福-Macoun会议上的一次演讲，它对-Swift-的反射-API-做了一个概述。" class="headerlink" title="尽管 Swift 一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi Packets和Core Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福 Macoun会议上的一次演讲，它对 Swift 的反射 API 做了一个概述。"></a>尽管 Swift 一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi Packets和Core Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福 Macoun会议上的一次演讲，它对 Swift 的反射 API 做了一个概述。</h2><blockquote>
<p>API 概述</p>
</blockquote>
<h4 id="理解这个主题最好的方式就是看-API，看它都提供了什么功能。"><a href="#理解这个主题最好的方式就是看-API，看它都提供了什么功能。" class="headerlink" title="理解这个主题最好的方式就是看 API，看它都提供了什么功能。"></a>理解这个主题最好的方式就是看 API，看它都提供了什么功能。</h4><blockquote>
<p>Mirror</p>
</blockquote>
<h4 id="Swift-的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。"><a href="#Swift-的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。" class="headerlink" title="Swift 的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。"></a>Swift 的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。</h4><h4 id="在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。"><a href="#在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。" class="headerlink" title="在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。"></a>在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import Foundation.NSURL// [译者注]此处应该为import Foundation</div><div class="line"></div><div class="line">publicclassStore&#123;</div><div class="line"></div><div class="line">letstoresToDisk:Bool=true</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">publicclassBookmarkStore:Store&#123;</div><div class="line"></div><div class="line">letitemCount:Int=10</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">publicstructBookmark&#123;</div><div class="line"></div><div class="line">enumGroup&#123;</div><div class="line"></div><div class="line">caseTech</div><div class="line"></div><div class="line">caseNews</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">privateletstore = &#123;</div><div class="line"></div><div class="line">returnBookmarkStore()</div><div class="line"></div><div class="line">&#125;()</div><div class="line"></div><div class="line">lettitle:String?</div><div class="line"></div><div class="line">leturl:NSURL</div><div class="line"></div><div class="line">letkeywords: [String]</div><div class="line"></div><div class="line">letgroup:Group</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">letaBookmark =Bookmark(title:&quot;Appventure&quot;, url:NSURL(string:&quot;appventure.me&quot;)!, keywords: [&quot;Swift&quot;,&quot;iOS&quot;,&quot;OSX&quot;], group: .Tech)</div></pre></td></tr></table></figure>
<blockquote>
<p>创建一个Mirror</p>
</blockquote>
<h4 id="创建Mirror最简单的方式就是使用reflecting构造器："><a href="#创建Mirror最简单的方式就是使用reflecting构造器：" class="headerlink" title="创建Mirror最简单的方式就是使用reflecting构造器："></a>创建Mirror最简单的方式就是使用reflecting构造器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public init(reflectingsubject:Any)</div></pre></td></tr></table></figure>
<h4 id="然后在aBookmarkstruct上使用它："><a href="#然后在aBookmarkstruct上使用它：" class="headerlink" title="然后在aBookmarkstruct上使用它："></a>然后在aBookmarkstruct上使用它：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let aMirror = Mirror(reflecting: aBookmark)</div><div class="line"></div><div class="line">print(aMirror)</div></pre></td></tr></table></figure>
<p>// 输出 : Mirror for Bookmark</p>
<h4 id="这段代码创建了Bookmark-的-Mirror。正如你所见，对象的类型是Any。这是-Swift-中最通用的类型。Swift-中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct-class-enum-Tuple-Array-Dictionary-set等。"><a href="#这段代码创建了Bookmark-的-Mirror。正如你所见，对象的类型是Any。这是-Swift-中最通用的类型。Swift-中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct-class-enum-Tuple-Array-Dictionary-set等。" class="headerlink" title="这段代码创建了Bookmark 的 Mirror。正如你所见，对象的类型是Any。这是 Swift 中最通用的类型。Swift 中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct,class,enum,Tuple,Array,Dictionary,set等。"></a>这段代码创建了Bookmark 的 Mirror。正如你所见，对象的类型是Any。这是 Swift 中最通用的类型。Swift 中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct,class,enum,Tuple,Array,Dictionary,set等。</h4><h4 id="Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。"><a href="#Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。" class="headerlink" title="Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。"></a>Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。</h4><blockquote>
<p>Mirror中都有什么？</p>
</blockquote>
<h4 id="Mirror-struct中包含几个types来帮助确定你想查询的信息。"><a href="#Mirror-struct中包含几个types来帮助确定你想查询的信息。" class="headerlink" title="Mirror struct中包含几个types来帮助确定你想查询的信息。"></a>Mirror struct中包含几个types来帮助确定你想查询的信息。</h4><h4 id="第一个是DisplayStyleenum，它会告诉你对象的类型："><a href="#第一个是DisplayStyleenum，它会告诉你对象的类型：" class="headerlink" title="第一个是DisplayStyleenum，它会告诉你对象的类型："></a>第一个是DisplayStyleenum，它会告诉你对象的类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">publicenumDisplayStyle&#123;</div><div class="line"></div><div class="line">caseStruct</div><div class="line"></div><div class="line">caseClass</div><div class="line"></div><div class="line">caseEnum</div><div class="line"></div><div class="line">caseTuple</div><div class="line"></div><div class="line">caseOptional</div><div class="line"></div><div class="line">caseCollection</div><div class="line"></div><div class="line">caseDictionary</div><div class="line"></div><div class="line">caseSet</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="这些都是反射-API-的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift-标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。"><a href="#这些都是反射-API-的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift-标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。" class="headerlink" title="这些都是反射 API 的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift 标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。"></a>这些都是反射 API 的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift 标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let closure = &#123; (a:Int) -&gt;Intinreturna *2&#125;</div><div class="line"></div><div class="line">let aMirror = Mirror(reflecting: closure)</div></pre></td></tr></table></figure>
<h4 id="在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2"><a href="#在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2" class="headerlink" title="在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2"></a>在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2</h4><h4 id="也有提供给Mirror的子节点使用的typealias："><a href="#也有提供给Mirror的子节点使用的typealias：" class="headerlink" title="也有提供给Mirror的子节点使用的typealias："></a>也有提供给Mirror的子节点使用的typealias：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public typealias Child = (label:String?, value:Any)</div></pre></td></tr></table></figure>
<h4 id="所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。"><a href="#所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。" class="headerlink" title="所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。"></a>所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。</h4><h4 id="接下来是AncestorRepresentationenum3："><a href="#接下来是AncestorRepresentationenum3：" class="headerlink" title="接下来是AncestorRepresentationenum3："></a>接下来是AncestorRepresentationenum3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public enum AncestorRepresentation&#123;</div><div class="line"></div><div class="line">/// 为所有 ancestor class 生成默认 mirror。</div><div class="line"></div><div class="line">case Generated</div><div class="line"></div><div class="line">/// 使用最近的 ancestor 的 customMirror() 实现来给它创建一个 mirror。</div><div class="line"></div><div class="line">case Customized(() -&gt;Mirror)</div><div class="line"></div><div class="line">/// 禁用所有 ancestor class 的行为。Mirror 的 superclassMirror() 返回值为 nil。</div><div class="line"></div><div class="line">case Suppressed</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下-Swift-会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation-enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。"><a href="#这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下-Swift-会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation-enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。" class="headerlink" title="这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下 Swift 会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。"></a>这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下 Swift 会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。</h4><blockquote>
<p>如何使用一个Mirror</p>
</blockquote>
<h4 id="现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？"><a href="#现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？" class="headerlink" title="现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？"></a>现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？</h4><h4 id="下面列举了Mirror可用的属性-方法："><a href="#下面列举了Mirror可用的属性-方法：" class="headerlink" title="下面列举了Mirror可用的属性 / 方法："></a>下面列举了Mirror可用的属性 / 方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let children: Children：对象的子节点。</div><div class="line"></div><div class="line">displayStyle: Mirror.DisplayStyle?：对象的展示风格</div><div class="line"></div><div class="line">let subjectType: Any.Type：对象的类型</div><div class="line"></div><div class="line">func superclassMirror() -&gt; Mirror?：对象父类的mirror</div></pre></td></tr></table></figure>
<h4 id="下面我们会分别对它们进行解析。"><a href="#下面我们会分别对它们进行解析。" class="headerlink" title="下面我们会分别对它们进行解析。"></a>下面我们会分别对它们进行解析。</h4><h4 id="displayStyle"><a href="#displayStyle" class="headerlink" title="displayStyle"></a>displayStyle</h4><h4 id="很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。"><a href="#很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。" class="headerlink" title="很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。"></a>很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。</h4><h4 id="print-aMirror-displayStyle"><a href="#print-aMirror-displayStyle" class="headerlink" title="print(aMirror.displayStyle)"></a>print(aMirror.displayStyle)</h4><h4 id="输出-Optional-Swift-Mirror-DisplayStyle-Struct"><a href="#输出-Optional-Swift-Mirror-DisplayStyle-Struct" class="headerlink" title="// 输出: Optional(Swift.Mirror.DisplayStyle.Struct)"></a>// 输出: Optional(Swift.Mirror.DisplayStyle.Struct)</h4><h4 id="译者注-此处输出：Optional-Struct"><a href="#译者注-此处输出：Optional-Struct" class="headerlink" title="// [译者注]此处输出：Optional(Struct)"></a>// [译者注]此处输出：Optional(Struct)</h4><h4 id="children"><a href="#children" class="headerlink" title="children"></a>children</h4><h4 id="这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。"><a href="#这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。" class="headerlink" title="这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。"></a>这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">forcaselet(label?, value)inaMirror.children &#123;</div><div class="line"></div><div class="line">print(label, value)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//输出:</div><div class="line"></div><div class="line">//: store main.BookmarkStore</div><div class="line"></div><div class="line">//: title Optional(&quot;Appventure&quot;)</div><div class="line"></div><div class="line">//: url appventure.me</div><div class="line"></div><div class="line">//: keywords [&quot;Swift&quot;, &quot;iOS&quot;, &quot;OSX&quot;]</div></pre></td></tr></table></figure>
<h4 id="group-Tech"><a href="#group-Tech" class="headerlink" title="//: group Tech"></a>//: group Tech</h4><h4 id="SubjectType"><a href="#SubjectType" class="headerlink" title="SubjectType"></a>SubjectType</h4><h4 id="这是对象的类型："><a href="#这是对象的类型：" class="headerlink" title="这是对象的类型："></a>这是对象的类型：</h4><h4 id="print-aMirror-subjectType"><a href="#print-aMirror-subjectType" class="headerlink" title="print(aMirror.subjectType)"></a>print(aMirror.subjectType)</h4><h4 id="输出-Bookmark"><a href="#输出-Bookmark" class="headerlink" title="//输出 : Bookmark"></a>//输出 : Bookmark</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">print(Mirror(reflecting:5).subjectType)</div><div class="line"></div><div class="line">//输出 : Int</div><div class="line"></div><div class="line">print(Mirror(reflecting:&quot;test&quot;).subjectType)</div><div class="line"></div><div class="line">//输出 : String</div><div class="line"></div><div class="line">print(Mirror(reflecting:NSNull()).subjectType)</div></pre></td></tr></table></figure>
<h4 id="输出-NSNull"><a href="#输出-NSNull" class="headerlink" title="//输出 : NSNull"></a>//输出 : NSNull</h4><h4 id="然而，Swift-的文档中有下面一句话：“当self是另外一个mirror的superclassMirror-时，这个类型和对象的动态类型可能会不一样。”"><a href="#然而，Swift-的文档中有下面一句话：“当self是另外一个mirror的superclassMirror-时，这个类型和对象的动态类型可能会不一样。”" class="headerlink" title="然而，Swift 的文档中有下面一句话：“当self是另外一个mirror的superclassMirror()时，这个类型和对象的动态类型可能会不一样。”"></a>然而，Swift 的文档中有下面一句话：“当self是另外一个mirror的superclassMirror()时，这个类型和对象的动态类型可能会不一样。”</h4><blockquote>
<p>SuperclassMirror</p>
</blockquote>
<h4 id="这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror："><a href="#这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror：" class="headerlink" title="这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror："></a>这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror：</h4><h4 id="试试-struct"><a href="#试试-struct" class="headerlink" title="// 试试 struct"></a>// 试试 struct</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print(Mirror(reflecting: aBookmark).superclassMirror())</div><div class="line"></div><div class="line">// 输出: nil</div><div class="line"></div><div class="line">// 试试 class</div><div class="line"></div><div class="line">print(Mirror(reflecting: aBookmark.store).superclassMirror())</div></pre></td></tr></table></figure>
<h4 id="输出-Optional-Mirror-for-Store"><a href="#输出-Optional-Mirror-for-Store" class="headerlink" title="// 输出: Optional(Mirror for Store)"></a>// 输出: Optional(Mirror for Store)</h4><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h4 id="Struct转Core-Data"><a href="#Struct转Core-Data" class="headerlink" title="Struct转Core Data"></a>Struct转Core Data</h4><h4 id="假设我们在一个叫Books-Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。"><a href="#假设我们在一个叫Books-Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。" class="headerlink" title="假设我们在一个叫Books Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。"></a>假设我们在一个叫Books Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。</h4><h4 id="现在是-2016-年，Swift-已经开源，所以我们的后台服务端肯定是用-Swift-编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们-AI-认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。"><a href="#现在是-2016-年，Swift-已经开源，所以我们的后台服务端肯定是用-Swift-编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们-AI-认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。" class="headerlink" title="现在是 2016 年，Swift 已经开源，所以我们的后台服务端肯定是用 Swift 编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们 AI 认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。"></a>现在是 2016 年，Swift 已经开源，所以我们的后台服务端肯定是用 Swift 编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们 AI 认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。</h4><h4 id="现在我们不想为每个新建的struct单独写自定义的Core-Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。"><a href="#现在我们不想为每个新建的struct单独写自定义的Core-Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。" class="headerlink" title="现在我们不想为每个新建的struct单独写自定义的Core Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。"></a>现在我们不想为每个新建的struct单独写自定义的Core Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。</h4><h4 id="那么我们该怎么做呢？"><a href="#那么我们该怎么做呢？" class="headerlink" title="那么我们该怎么做呢？"></a>那么我们该怎么做呢？</h4><h4 id="一个协议"><a href="#一个协议" class="headerlink" title="一个协议"></a>一个协议</h4><h4 id="记住，我们有一个struct，它需要自动转换为NSManagedObject（Core-Data）。"><a href="#记住，我们有一个struct，它需要自动转换为NSManagedObject（Core-Data）。" class="headerlink" title="记住，我们有一个struct，它需要自动转换为NSManagedObject（Core Data）。"></a>记住，我们有一个struct，它需要自动转换为NSManagedObject（Core Data）。</h4><h4 id="如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？"><a href="#如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？" class="headerlink" title="如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？"></a>如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？</h4><h4 id="第一，协议应该允许自定义我们想要创建的Core-Data-实体的名字"><a href="#第一，协议应该允许自定义我们想要创建的Core-Data-实体的名字" class="headerlink" title="第一，协议应该允许自定义我们想要创建的Core Data 实体的名字"></a>第一，协议应该允许自定义我们想要创建的Core Data 实体的名字</h4><h4 id="第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。"><a href="#第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。" class="headerlink" title="第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。"></a>第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。</h4><h4 id="我们的protocol（协议）-看起来是下面这个样子的："><a href="#我们的protocol（协议）-看起来是下面这个样子的：" class="headerlink" title="我们的protocol（协议） 看起来是下面这个样子的："></a>我们的protocol（协议） 看起来是下面这个样子的：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protocol StructDecoder&#123;</div><div class="line"></div><div class="line">// 我们 Core Data 实体的名字</div><div class="line"></div><div class="line">static var EntityName:String&#123;get&#125;</div><div class="line"></div><div class="line">// 返回包含我们属性集的 NSManagedObject</div><div class="line"></div><div class="line">func toCoreData(context: NSManagedObjectContext)throws-&gt;NSManagedObject//[译者注]使用 NSManagedObjectContext 需要 import CoreData</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="toCoreData方法使用了-Swift-2-0-新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举："><a href="#toCoreData方法使用了-Swift-2-0-新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举：" class="headerlink" title="toCoreData方法使用了 Swift 2.0 新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举："></a>toCoreData方法使用了 Swift 2.0 新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">enumSerializationError:ErrorType&#123;</div><div class="line"></div><div class="line">// 我们只支持 struct</div><div class="line"></div><div class="line">caseStructRequired</div><div class="line"></div><div class="line">// 实体在 Core Data 模型中不存在</div><div class="line"></div><div class="line">caseUnknownEntity(name:String)</div><div class="line"></div><div class="line">// 给定的类型不能保存在 core data 中</div><div class="line"></div><div class="line">caseUnsupportedSubType(label:String?)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在-Core-Data-模型中不存在。第三种情况是我们想要把一些不能存储在-Core-Data-中的东西保存到-Core-Data-中（即enum）。"><a href="#上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在-Core-Data-模型中不存在。第三种情况是我们想要把一些不能存储在-Core-Data-中的东西保存到-Core-Data-中（即enum）。" class="headerlink" title="上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在 Core Data 模型中不存在。第三种情况是我们想要把一些不能存储在 Core Data 中的东西保存到 Core Data 中（即enum）。"></a>上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在 Core Data 模型中不存在。第三种情况是我们想要把一些不能存储在 Core Data 中的东西保存到 Core Data 中（即enum）。</h4><h4 id="让我们创建一个struct然后为其增加协议一致性："><a href="#让我们创建一个struct然后为其增加协议一致性：" class="headerlink" title="让我们创建一个struct然后为其增加协议一致性："></a>让我们创建一个struct然后为其增加协议一致性：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Bookmark struct</div><div class="line"></div><div class="line">struct Bookmark&#123;</div><div class="line"></div><div class="line">let title:String</div><div class="line"></div><div class="line">let url:NSURL</div><div class="line"></div><div class="line">let pagerank:Int</div><div class="line"></div><div class="line">let created:NSDate</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="接下来，我们要实现toCoreData方法。"><a href="#接下来，我们要实现toCoreData方法。" class="headerlink" title="接下来，我们要实现toCoreData方法。"></a>接下来，我们要实现toCoreData方法。</h4><h4 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h4><h4 id="当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol-extension来扩展这个方法到所有相符合的struct："><a href="#当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol-extension来扩展这个方法到所有相符合的struct：" class="headerlink" title="当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol extension来扩展这个方法到所有相符合的struct："></a>当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol extension来扩展这个方法到所有相符合的struct：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extension StructDecoder&#123;</div><div class="line"></div><div class="line">func toCoreData(context: NSManagedObjectContext)throws-&gt;NSManagedObject&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。"><a href="#因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。" class="headerlink" title="因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。"></a>因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。</h4><h4 id="所以，我们需要做的第一步就是创建一个可以写入我们Bookmark-struct值的NSManagedObject。我们该怎么做呢？"><a href="#所以，我们需要做的第一步就是创建一个可以写入我们Bookmark-struct值的NSManagedObject。我们该怎么做呢？" class="headerlink" title="所以，我们需要做的第一步就是创建一个可以写入我们Bookmark struct值的NSManagedObject。我们该怎么做呢？"></a>所以，我们需要做的第一步就是创建一个可以写入我们Bookmark struct值的NSManagedObject。我们该怎么做呢？</h4><h4 id="一点Core-Data"><a href="#一点Core-Data" class="headerlink" title="一点Core Data"></a>一点Core Data</h4><h4 id="Core-Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤："><a href="#Core-Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤：" class="headerlink" title="Core Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤："></a>Core Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤：</h4><h4 id="获得我们需要创建的实体的名字（字符串）"><a href="#获得我们需要创建的实体的名字（字符串）" class="headerlink" title="获得我们需要创建的实体的名字（字符串）"></a>获得我们需要创建的实体的名字（字符串）</h4><h4 id="获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription"><a href="#获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription" class="headerlink" title="获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription"></a>获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription</h4><h4 id="利用这些信息创建NSManagedObject。"><a href="#利用这些信息创建NSManagedObject。" class="headerlink" title="利用这些信息创建NSManagedObject。"></a>利用这些信息创建NSManagedObject。</h4><h4 id="实现代码如下："><a href="#实现代码如下：" class="headerlink" title="实现代码如下："></a>实现代码如下：</h4><h4 id="获取-Core-Data-实体的名字"><a href="#获取-Core-Data-实体的名字" class="headerlink" title="// 获取 Core Data 实体的名字"></a>// 获取 Core Data 实体的名字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let entityName = self.dynamicType.EntityName</div></pre></td></tr></table></figure>
<h4 id="创建实体描述"><a href="#创建实体描述" class="headerlink" title="// 创建实体描述"></a>// 创建实体描述</h4><h4 id="实体可能不存在-所以我们使用-‘guard-let’-来判断，如果实体"><a href="#实体可能不存在-所以我们使用-‘guard-let’-来判断，如果实体" class="headerlink" title="// 实体可能不存在, 所以我们使用 ‘guard let’ 来判断，如果实体"></a>// 实体可能不存在, 所以我们使用 ‘guard let’ 来判断，如果实体</h4><h4 id="在我们的-core-data-模型中不存在的话，我们就抛出错误"><a href="#在我们的-core-data-模型中不存在的话，我们就抛出错误" class="headerlink" title="// 在我们的 core data 模型中不存在的话，我们就抛出错误"></a>// 在我们的 core data 模型中不存在的话，我们就抛出错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">guard let desc = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context)</div><div class="line"></div><div class="line">else &#123;</div><div class="line">throwUnknownEntity(name: entityName) &#125;// [译者注] UnknownEntity 为 SerializationError.UnknownEntity</div><div class="line"></div><div class="line">// 创建 NSManagedObject</div><div class="line"></div><div class="line">let managedObject = NSManagedObject(entity: desc, insertIntoManagedObjectContext: context)</div></pre></td></tr></table></figure>
<blockquote>
<p>实现反射</p>
</blockquote>
<h4 id="下一步，我们想使用反射-API-来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。"><a href="#下一步，我们想使用反射-API-来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。" class="headerlink" title="下一步，我们想使用反射 API 来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。"></a>下一步，我们想使用反射 API 来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。</h4><h4 id="创建-Mirror"><a href="#创建-Mirror" class="headerlink" title="// 创建 Mirror"></a>// 创建 Mirror</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let mirror = Mirror(reflecting:self)</div></pre></td></tr></table></figure>
<h4 id="确保我们是在分析一个-struct"><a href="#确保我们是在分析一个-struct" class="headerlink" title="// 确保我们是在分析一个 struct"></a>// 确保我们是在分析一个 struct</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">guard mirror.displayStyle == .Structelse&#123;throwSerializationError.StructRequired&#125;</div></pre></td></tr></table></figure>
<h4 id="我们通过测试displayStyle属性的方式来确保这是一个struct。"><a href="#我们通过测试displayStyle属性的方式来确保这是一个struct。" class="headerlink" title="我们通过测试displayStyle属性的方式来确保这是一个struct。"></a>我们通过测试displayStyle属性的方式来确保这是一个struct。</h4><h4 id="所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下："><a href="#所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下：" class="headerlink" title="所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下："></a>所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for case let(label?, value)inmirror.children &#123;</div><div class="line"></div><div class="line">managedObject.setValue(value, forKey: label)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject-类型的对象，而我们的children属性只返回一个-String-Any-类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum-，我们就可以抛出一个错误。"><a href="#太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject-类型的对象，而我们的children属性只返回一个-String-Any-类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum-，我们就可以抛出一个错误。" class="headerlink" title="太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject?类型的对象，而我们的children属性只返回一个(String?, Any)类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum)，我们就可以抛出一个错误。"></a>太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject?类型的对象，而我们的children属性只返回一个(String?, Any)类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum)，我们就可以抛出一个错误。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let mirror = Mirror(reflecting:self)</div><div class="line"></div><div class="line">guard mirror.displayStyle == .Struct</div><div class="line"></div><div class="line">else &#123;</div><div class="line">throwSerializationError.StructRequired&#125;</div><div class="line"></div><div class="line">for case let(label?, anyValue)inmirror.children &#123;</div><div class="line"></div><div class="line">if let value = anyValueas?AnyObject&#123;</div><div class="line"></div><div class="line">managedObject.setValue(child, forKey: label)// [译者注] 正确代码为：managedObject.setValue(value, forKey: label)</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">throwSerializationError.UnsupportedSubType(label: label)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。"><a href="#现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。" class="headerlink" title="现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。"></a>现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。</h4><h4 id="然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下："><a href="#然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下：" class="headerlink" title="然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下："></a>然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">extensionStructDecoder&#123;</div><div class="line"></div><div class="line">functoCoreData(context: NSManagedObjectContext)throws-&gt;NSManagedObject&#123;</div><div class="line"></div><div class="line">letentityName =self.dynamicType.EntityName</div><div class="line"></div><div class="line">// 创建实体描述</div><div class="line"></div><div class="line">guardletdesc =NSEntityDescription.entityForName(entityName, inManagedObjectContext: context)</div><div class="line"></div><div class="line">else&#123;throwUnknownEntity(name: entityName) &#125;// [译者注] UnknownEntity 为 SerializationError.UnknownEntity</div><div class="line"></div><div class="line">// 创建 NSManagedObject</div><div class="line"></div><div class="line">letmanagedObject =NSManagedObject(entity: desc, insertIntoManagedObjectContext: context)</div><div class="line"></div><div class="line">// 创建一个 Mirror</div><div class="line"></div><div class="line">letmirror =Mirror(reflecting:self)</div><div class="line"></div><div class="line">// 确保我们是在分析一个 struct</div><div class="line"></div><div class="line">guardmirror.displayStyle == .Structelse&#123;throwSerializationError.StructRequired&#125;</div><div class="line"></div><div class="line">forcaselet(label?, anyValue)inmirror.children &#123;</div><div class="line"></div><div class="line">ifletvalue = anyValueas?AnyObject&#123;</div><div class="line"></div><div class="line">managedObject.setValue(child, forKey: label)// [译者注] 正确代码为：managedObject.setValue(value, forKey: label)</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">throwSerializationError.UnsupportedSubType(label: label)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">returnmanagedObject</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="搞定，我们现在已经把struct转换为NSManagedObject了。"><a href="#搞定，我们现在已经把struct转换为NSManagedObject了。" class="headerlink" title="搞定，我们现在已经把struct转换为NSManagedObject了。"></a>搞定，我们现在已经把struct转换为NSManagedObject了。</h4><blockquote>
<p>性能</p>
</blockquote>
<h4 id="那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试："><a href="#那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试：" class="headerlink" title="那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试："></a>那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试：</h4><h4 id="创建2000个NSManagedObject"><a href="#创建2000个NSManagedObject" class="headerlink" title="创建2000个NSManagedObject"></a>创建2000个NSManagedObject</h4><h4 id="原生-0-062seconds"><a href="#原生-0-062seconds" class="headerlink" title="原生:0.062seconds"></a>原生:0.062seconds</h4><h4 id="反射-0-207seconds"><a href="#反射-0-207seconds" class="headerlink" title="反射:0.207seconds"></a>反射:0.207seconds</h4><h4 id="这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core-Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。"><a href="#这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core-Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。" class="headerlink" title="这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。"></a>这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。</h4><h4 id="所以正如你所见，使用反射使创建NSManagedObject的性能下降了3-5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你-app-的性能。"><a href="#所以正如你所见，使用反射使创建NSManagedObject的性能下降了3-5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你-app-的性能。" class="headerlink" title="所以正如你所见，使用反射使创建NSManagedObject的性能下降了3.5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你 app 的性能。"></a>所以正如你所见，使用反射使创建NSManagedObject的性能下降了3.5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你 app 的性能。</h4><blockquote>
<p>自定义Mirror</p>
</blockquote>
<h4 id="我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror-Struct提供了其他的构造器。"><a href="#我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror-Struct提供了其他的构造器。" class="headerlink" title="我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror Struct提供了其他的构造器。"></a>我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror Struct提供了其他的构造器。</h4><blockquote>
<p>Collection</p>
</blockquote>
<h4 id="第一个特殊init是为Collection量身定做的："><a href="#第一个特殊init是为Collection量身定做的：" class="headerlink" title="第一个特殊init是为Collection量身定做的："></a>第一个特殊init是为Collection量身定做的：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public init (_subject:T, children:C,displayStyle:Mirror.DisplayStyle? = default,ancestorRepresentation:Mirror.AncestorRepresentation=default)</div></pre></td></tr></table></figure>
<h4 id="与之前的init-reflecting-相比，这个构造器允许我们定义更多反射处理的细节。"><a href="#与之前的init-reflecting-相比，这个构造器允许我们定义更多反射处理的细节。" class="headerlink" title="与之前的init(reflecting:)相比，这个构造器允许我们定义更多反射处理的细节。"></a>与之前的init(reflecting:)相比，这个构造器允许我们定义更多反射处理的细节。</h4><h4 id="它只对Collection有效"><a href="#它只对Collection有效" class="headerlink" title="它只对Collection有效"></a>它只对Collection有效</h4><h4 id="我们可以设定被反射的对象以及对象的children（Collection的内容）"><a href="#我们可以设定被反射的对象以及对象的children（Collection的内容）" class="headerlink" title="我们可以设定被反射的对象以及对象的children（Collection的内容）"></a>我们可以设定被反射的对象以及对象的children（Collection的内容）</h4><h4 id="class或者struct"><a href="#class或者struct" class="headerlink" title="class或者struct"></a>class或者struct</h4><h4 id="第二个可以在class或者struct上使用。"><a href="#第二个可以在class或者struct上使用。" class="headerlink" title="第二个可以在class或者struct上使用。"></a>第二个可以在class或者struct上使用。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public init(_subject:T,</div><div class="line"></div><div class="line">children:DictionaryLiteral,</div><div class="line"></div><div class="line">displayStyle:Mirror.DisplayStyle? =default,</div><div class="line"></div><div class="line">ancestorRepresentation:Mirror.AncestorRepresentation=default)</div></pre></td></tr></table></figure>
<h4 id="有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark-struct实现这个构造器，它看起来是这样的："><a href="#有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark-struct实现这个构造器，它看起来是这样的：" class="headerlink" title="有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark struct实现这个构造器，它看起来是这样的："></a>有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark struct实现这个构造器，它看起来是这样的：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extension Bookmark:CustomReflectable&#123;</div><div class="line"></div><div class="line">func customMirror()-&gt;Mirror&#123;// [译者注] 此处应该为 public func customMirror() -&gt; Mirror &#123;</div><div class="line"></div><div class="line">let children = DictionaryLiteral(dictionaryLiteral:</div><div class="line"></div><div class="line">(&quot;title&quot;,self.title), (&quot;pagerank&quot;,self.pagerank),</div><div class="line"></div><div class="line">(&quot;url&quot;,self.url), (&quot;created&quot;,self.created),</div><div class="line"></div><div class="line">(&quot;keywords&quot;,self.keywords), (&quot;group&quot;,self.group))</div><div class="line"></div><div class="line">return Mirror.init(Bookmark.self, children: children,displayStyle:Mirror.DisplayStyle.Struct,ancestorRepresentation:.Suppressed)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升："><a href="#如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升：" class="headerlink" title="如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升："></a>如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升：</h4><h4 id="创建2000个NSManagedObject-1"><a href="#创建2000个NSManagedObject-1" class="headerlink" title="创建2000个NSManagedObject"></a>创建2000个NSManagedObject</h4><h4 id="原生-0-062seconds-1"><a href="#原生-0-062seconds-1" class="headerlink" title="原生:0.062seconds"></a>原生:0.062seconds</h4><h4 id="反射-0-207seconds-1"><a href="#反射-0-207seconds-1" class="headerlink" title="反射:0.207seconds"></a>反射:0.207seconds</h4><h4 id="反射-0-203seconds"><a href="#反射-0-203seconds" class="headerlink" title="反射:0.203seconds"></a>反射:0.203seconds</h4><h4 id="但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。"><a href="#但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。" class="headerlink" title="但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。"></a>但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。</h4><blockquote>
<p>用例</p>
</blockquote>
<h4 id="所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。"><a href="#所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。" class="headerlink" title="所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。"></a>所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。</h4><h4 id="而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。"><a href="#而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。" class="headerlink" title="而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。"></a>而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。</h4><h4 id="例子如下："><a href="#例子如下：" class="headerlink" title="例子如下："></a>例子如下：</h4><h4 id="记住上一次选择"><a href="#记住上一次选择" class="headerlink" title="记住上一次选择"></a>记住上一次选择</h4><h4 id="在重新启动时存储AST打开的项目"><a href="#在重新启动时存储AST打开的项目" class="headerlink" title="在重新启动时存储AST打开的项目"></a>在重新启动时存储AST打开的项目</h4><h4 id="在特殊处理时做临时存储"><a href="#在特殊处理时做临时存储" class="headerlink" title="在特殊处理时做临时存储"></a>在特殊处理时做临时存储</h4><h4 id="当然除此之外，反射当然还有其他的使用场景："><a href="#当然除此之外，反射当然还有其他的使用场景：" class="headerlink" title="当然除此之外，反射当然还有其他的使用场景："></a>当然除此之外，反射当然还有其他的使用场景：</h4><h4 id="遍历tuples"><a href="#遍历tuples" class="headerlink" title="遍历tuples"></a>遍历tuples</h4><h4 id="对类做分析"><a href="#对类做分析" class="headerlink" title="对类做分析"></a>对类做分析</h4><h4 id="运行时分析对象的一致性"><a href="#运行时分析对象的一致性" class="headerlink" title="运行时分析对象的一致性"></a>运行时分析对象的一致性</h4><h4 id="自动生成详细日志-调试信息（即外部生成对象）"><a href="#自动生成详细日志-调试信息（即外部生成对象）" class="headerlink" title="自动生成详细日志 / 调试信息（即外部生成对象）"></a>自动生成详细日志 / 调试信息（即外部生成对象）</h4><blockquote>
<p>讨论</p>
</blockquote>
<h4 id="反射-API-主要做为Playground的一个工具。符合反射-API-的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。"><a href="#反射-API-主要做为Playground的一个工具。符合反射-API-的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。" class="headerlink" title="反射 API 主要做为Playground的一个工具。符合反射 API 的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。"></a>反射 API 主要做为Playground的一个工具。符合反射 API 的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。</h4><blockquote>
<p>更多信息</p>
</blockquote>
<h4 id="反射-API-的源文件注释非常详细，我强烈建议每个人都去看看。"><a href="#反射-API-的源文件注释非常详细，我强烈建议每个人都去看看。" class="headerlink" title="反射 API 的源文件注释非常详细，我强烈建议每个人都去看看。"></a>反射 API 的源文件注释非常详细，我强烈建议每个人都去看看。</h4><h4 id="同时，GitHub-上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。"><a href="#同时，GitHub-上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。" class="headerlink" title="同时，GitHub 上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。"></a>同时，GitHub 上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。</h4><h4 id="1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。"><a href="#1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。" class="headerlink" title="1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。"></a>1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。</h4><h4 id="2、更确切地说，是一个空的可选类型。"><a href="#2、更确切地说，是一个空的可选类型。" class="headerlink" title="2、更确切地说，是一个空的可选类型。"></a>2、更确切地说，是一个空的可选类型。</h4><h4 id="3、我对注释稍微做了简化。"><a href="#3、我对注释稍微做了简化。" class="headerlink" title="3、我对注释稍微做了简化。"></a>3、我对注释稍微做了简化。</h4>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2017/06/14/Swift反射API及其用法/">Swift反射API及其用法</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 飘金 的个人博客">飘金</a></p>
        <p><span>发布时间:</span>2017年06月14日 - 14时23分</p>
        <p><span>最后更新:</span>2017年06月14日 - 22时13分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/06/14/Swift反射API及其用法/" title="Swift反射API及其用法">http://yoursite.com/2017/06/14/Swift反射API及其用法/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2017/06/14/Swift反射API及其用法/　　作者: 飘金" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2017/06/14/UIScrollView与AutoLayout或Masonry结合使用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          UIScrollView与AutoLayout或Masonry结合使用
        
      </div>
    </a>
  
  
    <a  href="/2017/06/14/Xcode控制台调试常用命令/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Xcode控制台调试常用命令</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#尽管-Swift-一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi-Packets和Core-Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福-Macoun会议上的一次演讲，它对-Swift-的反射-API-做了一个概述。"><span class="toc-number">1.</span> <span class="toc-text">尽管 Swift 一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似Tuples、Midi Packets和Core Data的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福 Macoun会议上的一次演讲，它对 Swift 的反射 API 做了一个概述。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理解这个主题最好的方式就是看-API，看它都提供了什么功能。"><span class="toc-number">1.0.1.</span> <span class="toc-text">理解这个主题最好的方式就是看 API，看它都提供了什么功能。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swift-的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。"><span class="toc-number">1.0.2.</span> <span class="toc-text">Swift 的反射机制是基于一个叫Mirror的struct来实现的。你为具体的subject创建一个Mirror，然后就可以通过它查询这个对象subject。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。"><span class="toc-number">1.0.3.</span> <span class="toc-text">在我们创建Mirror之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建Mirror最简单的方式就是使用reflecting构造器："><span class="toc-number">1.0.4.</span> <span class="toc-text">创建Mirror最简单的方式就是使用reflecting构造器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#然后在aBookmarkstruct上使用它："><span class="toc-number">1.0.5.</span> <span class="toc-text">然后在aBookmarkstruct上使用它：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这段代码创建了Bookmark-的-Mirror。正如你所见，对象的类型是Any。这是-Swift-中最通用的类型。Swift-中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct-class-enum-Tuple-Array-Dictionary-set等。"><span class="toc-number">1.0.6.</span> <span class="toc-text">这段代码创建了Bookmark 的 Mirror。正如你所见，对象的类型是Any。这是 Swift 中最通用的类型。Swift 中的任何东西至少都是Any类型的1。这样一来mirror就可以兼容struct,class,enum,Tuple,Array,Dictionary,set等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。"><span class="toc-number">1.0.7.</span> <span class="toc-text">Mirror结构体还有另外三个构造器，然而这三个都是在你需要自定义mirror这种情况下使用的。我们会在接下来讨论自定义mirror时详细讲解这些额外的构造器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mirror-struct中包含几个types来帮助确定你想查询的信息。"><span class="toc-number">1.0.8.</span> <span class="toc-text">Mirror struct中包含几个types来帮助确定你想查询的信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个是DisplayStyleenum，它会告诉你对象的类型："><span class="toc-number">1.0.9.</span> <span class="toc-text">第一个是DisplayStyleenum，它会告诉你对象的类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这些都是反射-API-的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift-标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。"><span class="toc-number">1.0.10.</span> <span class="toc-text">这些都是反射 API 的辅助类型。正如之前我们知道的，反射只要求对象是Any类型，而且Swift 标准库中还有很多类型为Any的东西没有被列举在上面的DisplayStyleenum中。如果试图反射它们中间的某一个又会发生什么呢？比如closure。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2"><span class="toc-number">1.0.11.</span> <span class="toc-text">在这种情况下，这里你会得到一个mirror，但是DisplayStyle为nil2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#也有提供给Mirror的子节点使用的typealias："><span class="toc-number">1.0.12.</span> <span class="toc-text">也有提供给Mirror的子节点使用的typealias：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。"><span class="toc-number">1.0.13.</span> <span class="toc-text">所以每个Child都包含一个可选的label和Any类型的value。为什么label是Optional的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。struct会以属性的名字做为label，但是Collection只有下标，没有名字。Tuple同样也可能没有给它们的条目指定名字。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接下来是AncestorRepresentationenum3："><span class="toc-number">1.0.14.</span> <span class="toc-text">接下来是AncestorRepresentationenum3：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下-Swift-会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation-enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。"><span class="toc-number">1.0.15.</span> <span class="toc-text">这个enum用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于class类型的对象。默认情况（正如你所见）下 Swift 会为每个父类生成额外的mirror。然而，如果你需要做更复杂的操作，你可以使用AncestorRepresentation enum来定义父类被反射的细节。我们会在下面的内容中进一步研究这个。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？"><span class="toc-number">1.0.16.</span> <span class="toc-text">现在我们有了给Bookmark类型的对象aBookmark做反射的实例变量aMirror。可以用它来做什么呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下面列举了Mirror可用的属性-方法："><span class="toc-number">1.0.17.</span> <span class="toc-text">下面列举了Mirror可用的属性 / 方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下面我们会分别对它们进行解析。"><span class="toc-number">1.0.18.</span> <span class="toc-text">下面我们会分别对它们进行解析。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#displayStyle"><span class="toc-number">1.0.19.</span> <span class="toc-text">displayStyle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。"><span class="toc-number">1.0.20.</span> <span class="toc-text">很简单，它会返回DisplayStyleenum的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的Optional值（这个之前解释过）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#print-aMirror-displayStyle"><span class="toc-number">1.0.21.</span> <span class="toc-text">print(aMirror.displayStyle)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出-Optional-Swift-Mirror-DisplayStyle-Struct"><span class="toc-number">1.0.22.</span> <span class="toc-text">// 输出: Optional(Swift.Mirror.DisplayStyle.Struct)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#译者注-此处输出：Optional-Struct"><span class="toc-number">1.0.23.</span> <span class="toc-text">// [译者注]此处输出：Optional(Struct)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#children"><span class="toc-number">1.0.24.</span> <span class="toc-text">children</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。"><span class="toc-number">1.0.25.</span> <span class="toc-text">这会返回一个包含了对象所有的子节点的AnyForwardCollection。这些子节点不单单限于Array或者Dictionary中的条目。诸如struct或者class中所有的属性也是由AnyForwardCollection这个属性返回的子节点。AnyForwardCollection协议意味着这是一个支持遍历的Collection类型。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-Tech"><span class="toc-number">1.0.26.</span> <span class="toc-text">//: group Tech</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubjectType"><span class="toc-number">1.0.27.</span> <span class="toc-text">SubjectType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这是对象的类型："><span class="toc-number">1.0.28.</span> <span class="toc-text">这是对象的类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#print-aMirror-subjectType"><span class="toc-number">1.0.29.</span> <span class="toc-text">print(aMirror.subjectType)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出-Bookmark"><span class="toc-number">1.0.30.</span> <span class="toc-text">//输出 : Bookmark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出-NSNull"><span class="toc-number">1.0.31.</span> <span class="toc-text">//输出 : NSNull</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#然而，Swift-的文档中有下面一句话：“当self是另外一个mirror的superclassMirror-时，这个类型和对象的动态类型可能会不一样。”"><span class="toc-number">1.0.32.</span> <span class="toc-text">然而，Swift 的文档中有下面一句话：“当self是另外一个mirror的superclassMirror()时，这个类型和对象的动态类型可能会不一样。”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror："><span class="toc-number">1.0.33.</span> <span class="toc-text">这是我们对象父类的mirror。如果这个对象不是一个类，它会是一个空的Optional值。如果对象的类型是基于类的，你会得到一个新的Mirror：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#试试-struct"><span class="toc-number">1.0.34.</span> <span class="toc-text">// 试试 struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输出-Optional-Mirror-for-Store"><span class="toc-number">1.0.35.</span> <span class="toc-text">// 输出: Optional(Mirror for Store)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例"><span class="toc-number">1.0.36.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Struct转Core-Data"><span class="toc-number">1.0.37.</span> <span class="toc-text">Struct转Core Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#假设我们在一个叫Books-Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。"><span class="toc-number">1.0.38.</span> <span class="toc-text">假设我们在一个叫Books Bunny的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在是-2016-年，Swift-已经开源，所以我们的后台服务端肯定是用-Swift-编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们-AI-认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。"><span class="toc-number">1.0.39.</span> <span class="toc-text">现在是 2016 年，Swift 已经开源，所以我们的后台服务端肯定是用 Swift 编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用struct来存储用户访问网站的分析数据。不过，如果我们 AI 认定某个页面的数据是需要保存到书签中的话，我们需要使用CoreData来把这个类型的对象保存到数据库中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在我们不想为每个新建的struct单独写自定义的Core-Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。"><span class="toc-number">1.0.40.</span> <span class="toc-text">现在我们不想为每个新建的struct单独写自定义的Core Data序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有struct都可以利用这种方式来做序列化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那么我们该怎么做呢？"><span class="toc-number">1.0.41.</span> <span class="toc-text">那么我们该怎么做呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个协议"><span class="toc-number">1.0.42.</span> <span class="toc-text">一个协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记住，我们有一个struct，它需要自动转换为NSManagedObject（Core-Data）。"><span class="toc-number">1.0.43.</span> <span class="toc-text">记住，我们有一个struct，它需要自动转换为NSManagedObject（Core Data）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？"><span class="toc-number">1.0.44.</span> <span class="toc-text">如果我们想要支持不同的struct甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一，协议应该允许自定义我们想要创建的Core-Data-实体的名字"><span class="toc-number">1.0.45.</span> <span class="toc-text">第一，协议应该允许自定义我们想要创建的Core Data 实体的名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。"><span class="toc-number">1.0.46.</span> <span class="toc-text">第二，协议需要提供一种方式来告诉它如何转换为NSManagedObject。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们的protocol（协议）-看起来是下面这个样子的："><span class="toc-number">1.0.47.</span> <span class="toc-text">我们的protocol（协议） 看起来是下面这个样子的：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toCoreData方法使用了-Swift-2-0-新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举："><span class="toc-number">1.0.48.</span> <span class="toc-text">toCoreData方法使用了 Swift 2.0 新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的ErrorTypeenum进行了列举：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在-Core-Data-模型中不存在。第三种情况是我们想要把一些不能存储在-Core-Data-中的东西保存到-Core-Data-中（即enum）。"><span class="toc-number">1.0.49.</span> <span class="toc-text">上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非struct的对象上。第二种情况是我们想要创建的entity在 Core Data 模型中不存在。第三种情况是我们想要把一些不能存储在 Core Data 中的东西保存到 Core Data 中（即enum）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#让我们创建一个struct然后为其增加协议一致性："><span class="toc-number">1.0.50.</span> <span class="toc-text">让我们创建一个struct然后为其增加协议一致性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接下来，我们要实现toCoreData方法。"><span class="toc-number">1.0.51.</span> <span class="toc-text">接下来，我们要实现toCoreData方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协议扩展"><span class="toc-number">1.0.52.</span> <span class="toc-text">协议扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol-extension来扩展这个方法到所有相符合的struct："><span class="toc-number">1.0.53.</span> <span class="toc-text">当然我们可以为每个struct都写新的toCoreData方法，但是工作量很大，因为struct不支持继承，所以我们不能使用基类的方式。不过我们可以使用protocol extension来扩展这个方法到所有相符合的struct：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。"><span class="toc-number">1.0.54.</span> <span class="toc-text">因为扩展已经被应用到相符合的struct，这个方法就可以在struct的上下文中被调用。因此，在协议中，self指的是我们想分析的struct。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所以，我们需要做的第一步就是创建一个可以写入我们Bookmark-struct值的NSManagedObject。我们该怎么做呢？"><span class="toc-number">1.0.55.</span> <span class="toc-text">所以，我们需要做的第一步就是创建一个可以写入我们Bookmark struct值的NSManagedObject。我们该怎么做呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一点Core-Data"><span class="toc-number">1.0.56.</span> <span class="toc-text">一点Core Data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤："><span class="toc-number">1.0.57.</span> <span class="toc-text">Core Data有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获得我们需要创建的实体的名字（字符串）"><span class="toc-number">1.0.58.</span> <span class="toc-text">获得我们需要创建的实体的名字（字符串）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription"><span class="toc-number">1.0.59.</span> <span class="toc-text">获取NSManagedObjectContext，然后为我们的实体创建NSEntityDescription</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用这些信息创建NSManagedObject。"><span class="toc-number">1.0.60.</span> <span class="toc-text">利用这些信息创建NSManagedObject。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现代码如下："><span class="toc-number">1.0.61.</span> <span class="toc-text">实现代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取-Core-Data-实体的名字"><span class="toc-number">1.0.62.</span> <span class="toc-text">// 获取 Core Data 实体的名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建实体描述"><span class="toc-number">1.0.63.</span> <span class="toc-text">// 创建实体描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实体可能不存在-所以我们使用-‘guard-let’-来判断，如果实体"><span class="toc-number">1.0.64.</span> <span class="toc-text">// 实体可能不存在, 所以我们使用 ‘guard let’ 来判断，如果实体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在我们的-core-data-模型中不存在的话，我们就抛出错误"><span class="toc-number">1.0.65.</span> <span class="toc-text">// 在我们的 core data 模型中不存在的话，我们就抛出错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下一步，我们想使用反射-API-来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。"><span class="toc-number">1.0.66.</span> <span class="toc-text">下一步，我们想使用反射 API 来读取bookmark对象的属性然后把它写入到NSManagedObject实例中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建-Mirror"><span class="toc-number">1.0.67.</span> <span class="toc-text">// 创建 Mirror</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确保我们是在分析一个-struct"><span class="toc-number">1.0.68.</span> <span class="toc-text">// 确保我们是在分析一个 struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们通过测试displayStyle属性的方式来确保这是一个struct。"><span class="toc-number">1.0.69.</span> <span class="toc-text">我们通过测试displayStyle属性的方式来确保这是一个struct。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下："><span class="toc-number">1.0.70.</span> <span class="toc-text">所以现在我们有了一个可以让我们读取属性的Mirror，也有了一个可以用来设置属性的NSManagedObject。因为mirror提供了读取所有children的方式，所以我们可以遍历它们并保存它们的值。方式如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject-类型的对象，而我们的children属性只返回一个-String-Any-类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum-，我们就可以抛出一个错误。"><span class="toc-number">1.0.71.</span> <span class="toc-text">太棒了！但是，如果我们试图编译它，它会失败。原因是setValueForKey需要一个AnyObject?类型的对象，而我们的children属性只返回一个(String?, Any)类型的tuple。也就是说value是Any类型但是我们需要AnyObject类型的。为了解决这个问题，我们要测试value的AnyObject协议一致性。这也意味着如果得到的属性的类型不符合AnyObject协议（比如enum)，我们就可以抛出一个错误。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。"><span class="toc-number">1.0.72.</span> <span class="toc-text">现在，只有在child是AnyObject类型的时候我们才会调用setValueForKey方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下："><span class="toc-number">1.0.73.</span> <span class="toc-text">然后唯一剩下的事情就是返回NSManagedObject。完整的代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#搞定，我们现在已经把struct转换为NSManagedObject了。"><span class="toc-number">1.0.74.</span> <span class="toc-text">搞定，我们现在已经把struct转换为NSManagedObject了。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试："><span class="toc-number">1.0.75.</span> <span class="toc-text">那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建2000个NSManagedObject"><span class="toc-number">1.0.76.</span> <span class="toc-text">创建2000个NSManagedObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原生-0-062seconds"><span class="toc-number">1.0.77.</span> <span class="toc-text">原生:0.062seconds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射-0-207seconds"><span class="toc-number">1.0.78.</span> <span class="toc-text">反射:0.207seconds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core-Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。"><span class="toc-number">1.0.79.</span> <span class="toc-text">这里的原生是指创建一个NSManagedObject，然后通过setValueForKey设置属性值。如果你在Core Data内创建一个NSManagedObject子类然后把值直接设置到属性上（没有了动态setValueForKey的开销），速度可能更快。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所以正如你所见，使用反射使创建NSManagedObject的性能下降了3-5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你-app-的性能。"><span class="toc-number">1.0.80.</span> <span class="toc-text">所以正如你所见，使用反射使创建NSManagedObject的性能下降了3.5倍。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的struct时，这个方法可能会大大降低你 app 的性能。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror-Struct提供了其他的构造器。"><span class="toc-number">1.0.81.</span> <span class="toc-text">我们之前已经讨论过，创建Mirror还有其他的选项。这些选项是非常有用的，比如，你想自己定义mirror中对象的哪些部分是可访问的。对于这种情况Mirror Struct提供了其他的构造器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个特殊init是为Collection量身定做的："><span class="toc-number">1.0.82.</span> <span class="toc-text">第一个特殊init是为Collection量身定做的：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与之前的init-reflecting-相比，这个构造器允许我们定义更多反射处理的细节。"><span class="toc-number">1.0.83.</span> <span class="toc-text">与之前的init(reflecting:)相比，这个构造器允许我们定义更多反射处理的细节。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#它只对Collection有效"><span class="toc-number">1.0.84.</span> <span class="toc-text">它只对Collection有效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们可以设定被反射的对象以及对象的children（Collection的内容）"><span class="toc-number">1.0.85.</span> <span class="toc-text">我们可以设定被反射的对象以及对象的children（Collection的内容）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class或者struct"><span class="toc-number">1.0.86.</span> <span class="toc-text">class或者struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二个可以在class或者struct上使用。"><span class="toc-number">1.0.87.</span> <span class="toc-text">第二个可以在class或者struct上使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark-struct实现这个构造器，它看起来是这样的："><span class="toc-number">1.0.88.</span> <span class="toc-text">有意思的是，这里是由你指定对象的children（即属性），指定的方式是通过一个DictionaryLiteral，它有点像字典，可以直接用作函数参数。如果我们为Bookmark struct实现这个构造器，它看起来是这样的：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升："><span class="toc-number">1.0.89.</span> <span class="toc-text">如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建2000个NSManagedObject-1"><span class="toc-number">1.0.90.</span> <span class="toc-text">创建2000个NSManagedObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原生-0-062seconds-1"><span class="toc-number">1.0.91.</span> <span class="toc-text">原生:0.062seconds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射-0-207seconds-1"><span class="toc-number">1.0.92.</span> <span class="toc-text">反射:0.207seconds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射-0-203seconds"><span class="toc-number">1.0.93.</span> <span class="toc-text">反射:0.203seconds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。"><span class="toc-number">1.0.94.</span> <span class="toc-text">但这个工作几乎没有任何价值，因为它与我们之前反射struct成员变量的初衷是相违背的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。"><span class="toc-number">1.0.95.</span> <span class="toc-text">所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多NSManagedObject上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个struct，根据自己掌握的struct领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。"><span class="toc-number">1.0.96.</span> <span class="toc-text">而本文展示反射技巧可以当你在有很多复杂的struct，且偶尔想对它们中的一部分进行存储时使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子如下："><span class="toc-number">1.0.97.</span> <span class="toc-text">例子如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记住上一次选择"><span class="toc-number">1.0.98.</span> <span class="toc-text">记住上一次选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在重新启动时存储AST打开的项目"><span class="toc-number">1.0.99.</span> <span class="toc-text">在重新启动时存储AST打开的项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在特殊处理时做临时存储"><span class="toc-number">1.0.100.</span> <span class="toc-text">在特殊处理时做临时存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当然除此之外，反射当然还有其他的使用场景："><span class="toc-number">1.0.101.</span> <span class="toc-text">当然除此之外，反射当然还有其他的使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历tuples"><span class="toc-number">1.0.102.</span> <span class="toc-text">遍历tuples</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对类做分析"><span class="toc-number">1.0.103.</span> <span class="toc-text">对类做分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时分析对象的一致性"><span class="toc-number">1.0.104.</span> <span class="toc-text">运行时分析对象的一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动生成详细日志-调试信息（即外部生成对象）"><span class="toc-number">1.0.105.</span> <span class="toc-text">自动生成详细日志 / 调试信息（即外部生成对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射-API-主要做为Playground的一个工具。符合反射-API-的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。"><span class="toc-number">1.0.106.</span> <span class="toc-text">反射 API 主要做为Playground的一个工具。符合反射 API 的对象可以很轻松滴就在Playground的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在Playground之外仍然有很多有趣的应用场景，这些应用场景我们在用例章节中都讲解过。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反射-API-的源文件注释非常详细，我强烈建议每个人都去看看。"><span class="toc-number">1.0.107.</span> <span class="toc-text">反射 API 的源文件注释非常详细，我强烈建议每个人都去看看。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同时，GitHub-上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。"><span class="toc-number">1.0.108.</span> <span class="toc-text">同时，GitHub 上的CoreValue项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把struct编码成CoreData，或者把CoreData解码成struct。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。"><span class="toc-number">1.0.109.</span> <span class="toc-text">1、实际上，Any是一个空的协议，所有的东西都隐式滴符合这个协议。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、更确切地说，是一个空的可选类型。"><span class="toc-number">1.0.110.</span> <span class="toc-text">2、更确切地说，是一个空的可选类型。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、我对注释稍微做了简化。"><span class="toc-number">1.0.111.</span> <span class="toc-text">3、我对注释稍微做了简化。</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section class="changyan" id="comments">
  <!--<div id="uyan_frame"></div>-->
  <div id="SOHUCS"></div>
  <script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js"></script>
  <script type="text/javascript">
    window.changyan.api.config({
      appid: 'xxxx',
      conf: 'xxxxxxxxx'
    });
  </script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2017/06/14/UIScrollView与AutoLayout或Masonry结合使用/" title="上一篇: UIScrollView与AutoLayout或Masonry结合使用">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2017/06/14/Xcode控制台调试常用命令/" title="下一篇: Xcode控制台调试常用命令">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/Observer监听RunLoop状态变化(kCFRunLoopBeforeWaiting,kCFRunLoopAfterWaiting等)/">Observer监听RunLoop状态变化(kCFRunLoopBeforeWaiting,kCFRunLoopAfterWaiting等)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/深入理解RunLoop/">深入理解RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop与NSURLConnection/">RunLoop与NSURLConnection</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop与PerformSelector/">RunLoop与PerformSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop与Timer以及常用Mode/">RunLoop与Timer以及常用Mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop与线程与GCD的关系/">RunLoop与线程与GCD的关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时(一)/">RunTime运行时(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时(二)/">RunTime运行时(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop的内部逻辑/">RunLoop的内部逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时(三)/">RunTime运行时(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时之动态替换和改变方法实现/">RunTime运行时之动态替换和改变方法实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时之动态添加方法/">RunTime运行时之动态添加方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时之成员变量和属性/">RunTime运行时之成员变量和属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunTime运行时之改变私有属性的值/">RunTime运行时之改变私有属性的值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/Runtime运行时之Class常用方法/">Runtime运行时之Class常用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/SpriteKitSwiftGamePanda/">用SpriteKit写的熊猫跑酷小游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/RunLoop与AutoreleasePool/">RunLoop与AutoreleasePool</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/实例化讲解RunLoop/">实例化讲解RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/离屏渲染浅析/">离屏渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/tableView cell 中如果有文本框点击自动滚动不被键盘挡住/">tableView cell 中如果有文本框点击自动滚动不被键盘挡住</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Swift利用反射机制(Mirror)获取类的属性列表与值/">Swift利用反射机制(Mirror)获取类的属性列表与值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/UIScrollView与AutoLayout或Masonry结合使用/">UIScrollView与AutoLayout或Masonry结合使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Swift反射API及其用法/">Swift反射API及其用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Xcode控制台调试常用命令/">Xcode控制台调试常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Swift中有个双问号操作符/">Swift中有个双问号操作符</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Swift枚举相关值/">Swift枚举相关值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/iOS 设置视图半透明而子控件不透明/">iOS 设置视图半透明而子控件不透明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/使用Swift Package Manager管理项目(the package has an unsupported layout)/">使用Swift Package Manager管理项目(the package has an unsupported layout)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/基于Perfect的Swift3.1服务器开发案例/">基于Perfect的Swift3.1服务器开发案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/如何创建一个纯 Swift 模块/">如何创建一个纯 Swift 模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Swift之Defer/">Swift之Defer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/iOS clang编译OC成C++文件/">iOS clang编译OC成C++文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/calayer-uiview-uiwindow/">UIView,UIWindow,CALayer之间的区别联系</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 飘金
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 4;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>